<!DOCTYPE html>
<html>
<head>
  <title>TrainO</title>
</head>
<body>
  <div ng-controller="mainCtrl">

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="210mm"
   height="297mm"
   viewBox="0 0 210 297"
   version="1.1"
   id="svg8"
   inkscape:version="0.92.1 r15371"
   sodipodi:docname="new_traino.svg">
  <defs id="defs2">
    <linearGradient
       inkscape:collect="always"
       id="linearGradient4621">
    <stop
       style="stop-color:#1a1a1a;stop-opacity:1;"
       offset="0"
       id="stop4497" />
    <stop
       style="stop-color:#dadada;stop-opacity:1;"
       offset="1"
       id="stop4499" />
   </linearGradient>
    <g
       transform="matrix(0.07594997,0,0,0.07594997,-3.9,-11)"
       id="engine">
      <rect
         y="114.62624"
         x="39.507156"
         height="43.928146"
         width="21.430294"
         id="rect3680-6"
         style="fill:url(#linearGradient4621);fill-opacity:1;stroke:#000000;stroke-width:0.098;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
      <rect
         y="158.55438"
         x="34.69669"
         height="27.79603"
         width="31.003265"
         id="rect3682-2"
         style="fill:#6e716e;fill-opacity:1;stroke:#050000;stroke-width:0.16500001;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
      <rect
         y="119.96303"
         x="60.783539"
         height="11.579324"
         width="4.1365209"
         id="rect4507-9"
         style="fill:#6f6b6a;fill-opacity:1;stroke:#000000;stroke-width:0.06534843;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
      <rect
         y="120.24654"
         x="35.23518"
         height="11.579324"
         width="4.1365209"
         id="rect4507-3-1"
         style="fill:#6f6b6a;fill-opacity:1;stroke:#000000;stroke-width:0.06534843;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
      <ellipse
         ry="4.3467264"
         rx="4.0632439"
         cy="122.22382"
         cx="50.025143"
         id="path4524-2"
         style="fill:#6f6b6a;fill-opacity:1;stroke:#000000;stroke-width:0.098;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
      <ellipse
         ry="2.6648846"
         rx="2.4758959"
         cy="122.03484"
         cx="50.025143"
         id="path4524-6-7"
         style="fill:#0b0a0a;fill-opacity:1;stroke:#000000;stroke-width:0.05989821;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
      <path
         sodipodi:nodetypes="cccc"
         inkscape:connector-curvature="0"
         id="path4541-0"
         d="m 46.905329,152.88474 v 5.66964 H 35.755024 Z"
         style="fill:#99d2df;fill-opacity:1;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
      <path
         sodipodi:nodetypes="cccc"
         inkscape:connector-curvature="0"
         id="path4541-7-9"
         d="m 53.7845,152.88474 v 5.66964 h 11.150311 z"
         style="fill:#99d2df;fill-opacity:1;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
      <rect
         y="152.84326"
         x="46.905331"
         height="5.7111182"
         width="6.8035712"
         id="rect4558-3"
         style="fill:#99d2df;fill-opacity:1;stroke:#000000;stroke-width:0.09378048;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
    </g>  
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="0.64230499"
     inkscape:cx="155.53201"
     inkscape:cy="561.25984"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="false"
     inkscape:window-width="1824"
     inkscape:window-height="920"
     inkscape:window-x="0"
     inkscape:window-y="36"
     inkscape:window-maximized="1" />
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <style>
    .small { font:  6px sans-serif; }
  </style>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1">
    <rect
       style="fill:#99ff99;fill-opacity:1;stroke:#050000;stroke-width:0.72415805;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
       id="rect10"
       width="201"
       height="291"
       x="0"
       y="0" />
    <g ng-repeat="city_random in sst.city_randoms">
      <ellipse ng-attr-cx="{{city_random.x}}" ng-attr-cy="{{city_random.y}}" rx="1" ry="1" />
      <text ng-attr-x="{{city_random.x + 2}}" ng-attr-y="{{city_random.y}}" class="small">{{sst.city_names[$index]}}</text>
    </g>
    <g ng-repeat="track in sst.tracks">
      <path ng-attr-d="{{build_svg_path_d(track.waypoints)}}" fill="transparent" stroke="black">
    </g>
    <g>
      <text x="10" y="10" class="small">{{sst.engines[0].track_dist}}</text>
    </g>
    <g>
      <use xlink:href="#engine" ng-attr-x="{{sst.city_randoms[0].x}}" ng-attr-y="{{sst.city_randoms[0].y}}" />
    </g>
  </g>
  
</svg>

    
  </div>
  
  <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.7.6/angular.min.js" type="text/javascript"></script>
  <script>
    // Bootstrap angular module `app`
    angular.element(document.body).ready(function () {
      angular.bootstrap(document.body, ['app'])
    })
    // Declare module `app`, angular dependency modules go here
    var app = angular.module('app', [])
    
    app.controller("mainCtrl", function($scope) {
      $scope.sst = {};
      
      $scope.get_dist = function(x1, y1, x2, y2) {
        let dx = x1 - x2;
        let dy = y1 - y2;
        return dist = Math.sqrt(dx*dx + dy*dy);
      }

      $scope.unique_random = function(range, array_size, array, array2) {  // array2 is required but set to [] if not needed
        if (range < (array_size + array2.length) ){
          return;
        }
        for (let i=0; i<array_size; i++) {
          ran = Math.trunc(Math.random()*range);
          let max = 0;
          while ( (array.includes(ran) || array2.includes(ran)) && max < 10) {
            ran = Math.trunc(Math.random()*range);
            max++;
          }
          array.push(ran);
        }
      }  

      $scope.init_city_randoms = function() {
        for (let i=0; i<$scope.sst.N_CITIES; i++) {
          $scope.sst.city_randoms[i] = {};
          let this_city = $scope.sst.city_randoms[i];
          this_city.production = [];
          this_city.name = $scope.sst.city_names[i]
          //alert(this_city.production.length);
          $scope.unique_random($scope.sst.N_ITEM_TYPES, $scope.sst.N_PRODUCE, this_city.production, []);
          this_city.demand = [];
          $scope.unique_random($scope.sst.N_ITEM_TYPES, $scope.sst.N_DEMAND, this_city.demand, this_city.production);
        }
      }

      $scope.set_production_depletion_rates = function() {
        /* Random */
        for (let i=0; i<$scope.sst.N_CITIES; i++) {
          let this_city = $scope.sst.city_randoms[i];
          this_city.production_rates = [];
          for (let j=0; j<$scope.sst.N_PRODUCE; j++) {
            this_city.production_rates[j] = Math.random();
          }
          this_city.demand_rates = [];
          for (let j=0; j<$scope.sst.N_DEMAND; j++) {
            this_city.demand_rates[j] = Math.random();
          }
        }
      }
      
      $scope.build_svg_path_d = function(points) {
        let d = "M " + points[0].x + " " + points[0].y + " L ";
        for (let i = 1; i<points.length; i++) {
           d += points[i].x + " " + points[i].y + " ";
        }
        return d;
      }
      
      $scope.set_track_straight = function(city1, city2) {
        for (let i=0; i<$scope.sst.tracks.length; i++) {
          let this_track = $scope.sst.tracks[i];
          if ((this_track.city1 === city1 && this_track.city2 === city2)|| (this_track.city2 === city1 && this_track.city1 === city2)) {
            alert('Tracks between ' + city1 + ' to ' + city2 + ' is already established');
            return 0;
          }
        }
        let x1 = $scope.sst.city_randoms[city1].x;
        let y1 = $scope.sst.city_randoms[city1].y;
        let x2 = $scope.sst.city_randoms[city2].x;
        let y2 = $scope.sst.city_randoms[city2].y;
        
        let new_track = {city1: city1, city2: city2};
        
        new_track.waypoints = [{x: x1, y: y1},
                                   {x: x2, y: y2}];
        new_track.total_dist = $scope.get_dist(x1, y1, x2, y2);
        $scope.sst.tracks.push(new_track);
      }

      $scope.set_city_locations = function() {
        for (let i=0; i<$scope.sst.N_CITIES; i++) {
          let bad_placement = true;
          let max = 0;
          while (bad_placement && max < 20) {
            max++;
            $scope.sst.city_randoms[i].x = Math.random() * ($scope.sst.MAP_SIZE.X - 10) + 5;
            $scope.sst.city_randoms[i].y = Math.random() * ($scope.sst.MAP_SIZE.Y - 10) + 5;
            bad_placement = false;
            for (let j=0; j<i; j++) {
              let dist = $scope.get_dist($scope.sst.city_randoms[i].x, $scope.sst.city_randoms[i].y, $scope.sst.city_randoms[j].x, $scope.sst.city_randoms[j].y)
              if (dist < $scope.sst.MIN_RADIUS_PLACEMENT) {
                bad_placement = true;
                break;
              }
            }
          }
          if (max >= 20) {
            return 0;
          }
        }  
        return 1;
      }
      
      $scope.city_summary = function() {
        let summary = "";
        for (let i=0; i<$scope.sst.N_CITIES; i++) {
          summary += $scope.sst.city_randoms[i].name + "\n";
          summary += "   Supplies: ";
          for (let j=0; j<$scope.sst.N_PRODUCE; j++) {
            summary += $scope.sst.item_names[$scope.sst.city_randoms[i].production[j]] + ", ";
           }
           summary = summary.substring(0, summary.length - 2)+ "\n";
          summary += "   Demands: ";
          for (let j=0; j<$scope.sst.N_PRODUCE; j++) {
            summary += $scope.sst.item_names[$scope.sst.city_randoms[i].demand[j]] + ", ";
           }
           summary = summary.substring(0, summary.length - 2)+ "\n";                     
        }
        alert(summary);
      }
      
      $scope.place_engine = function(track, track_dist, speed) {
        $scope.sst.engines.push({track: track, track_dist: track_dist, rate: speed});
      }
      
      $scope.main_loop = function() {
      $scope.sst.tick++;
      for (let i=0; i<$scope.sst.engines.length; i++) {
        let engine = $scope.sst.engines[i]; 
        // move
        engine.track_dist += engine.rate;
        if (engine.track_dist >= $scope.sst.tracks[engine.track].length) {  // TODO: This should be replaced by routes.
           engine.track_dist = $scope.sst.tracks[engine.track].length;
          engine.rate = -engine.rate;   // TODO: handle turn-around time
        } else if (engine.track_dist <= 0.0) {
          engine.track_dist = 0;
          engine.rate = -engine.rate;   // TODO: handle turn-around time
        }
        let point = $scope.get_xy($scope.sst.tracks[0], engine.track_dist);
        engine.x = point.x;
        engine.y = point.y;
        engine.azimuth = point.theta * 180.0 / Math.pi;
      }
      }

      $scope.sst.city_names = ['Braxton', 'Hale', 'Manchester', 'Pullman', 'Westboro', 'Colville', 'Loomis', 'Quincy'];
      $scope.sst.city_randoms = [];
      $scope.sst.item_names = ["Steel", "Iron Ore", "Wool", "Wheat Grain", "Flour", "Bread", "Cattle", "Coal", "Rice", "Tools", "Milk", "Cheese", "Oranges", "Meat", "Cloth", "Clothing", "Corn", "Lumber", "Bananas", "Fish"];
      $scope.sst.N_CITIES = $scope.sst.city_names.length;
      $scope.sst.engines = [];
      $scope.place_engine(0, 0, 0.01);
      $scope.sst.tracks = [];
      
      $scope.sst.N_ITEM_TYPES = $scope.sst.item_names.length;
      $scope.sst.N_PRODUCE = 4;
      $scope.sst.N_DEMAND = 4;
      $scope.sst.MAP_SIZE = {};
      $scope.sst.MAP_SIZE.X = 202;
      $scope.sst.MAP_SIZE.Y = 290;
      $scope.sst.MIN_RADIUS_PLACEMENT = 40;
      $scope.sst.fixed_items = ["Passengers", "Mail"];
      $scope.sst.tick = 0;
      
      $scope.init_city_randoms();
      $scope.set_production_depletion_rates();

      if (!$scope.set_city_locations()) {
        alert("failed to set city locations");
      }      
      $scope.set_track_straight(0,1);
      $scope.city_summary();
      setInterval($scope.main_loop, 200);

    $scope.get_xyth - function(track, screen_dist) {
      let x = track.waypoints[0].x;
      let y = track.waypoints[0].y;
      let dy = track.waypoints[0].y - track.waypoints[1].y;
      let dx = track.waypoints[0].x - track.waypoints[1].x;
      let theta = Math.arctan2(dy, dx);
      return {x: x, y: y, theta: theta};
    }
      
      $scope.get_xy = function(track, screen_dist) {
        let leg1 = {};
        let leg2 = {};
        let sum_dist = 0;
        for (let i=0; i<track.waypoints.length - 1; i++) {
          leg1 = track.waypoints[i];
          leg2 = track.waypoints[i+1];
          let x1 = leg1.x;
          let y1 = leg1.y;
          let x2 = leg2.x;
          let y2 = leg2.y; 
          if (!track.waypoints[i].leg_dist) {
            track.waypoints[i].leg_dist = $scope.get_dist(x1, x2, y1, y2);
          }
          if (sum_dist + track.waypoints[i].leg_dist > screen_dist) {
            // Prorate the distance.
            remain_dist = (screen_dist - sum_dist);
            let ratio = remain_dist / track.waypoints[i].leg_dist;
            let dy = y1-y2;
            let dx = x1-x2;
            return {x: ratio * dx, y: ratio * dy, theta: Math.atan2(dy,dx)};
          }
          sum_dist += track.waypoints[i].leg_dist;
        }
      }
     });

  </script>
</body>
</html>
